<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础知识点总结</title>
      <link href="/2019/12/09/hello-world/"/>
      <url>/2019/12/09/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a><strong>Java基础知识</strong></h3><ul><li><p>在Java中，所有的数值类型所占据的字节数量与平台无关。</p></li><li><p>Java实际上没有多维数组，只有一维数组。</p></li><li><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p></li><li><p>构造器总是伴随着new操作符的执行被调用。</p></li><li><p>可以认为静态方法是没有this参数的方法。</p></li><li><p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</strong></p></li><li><p>必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的域，将会自动初始化为默认值（0，false或null）。</p></li><li><p>在Java 中，所有的继承都是公有继承。</p></li><li><p>有些人认为super与this引用是类似的概念， 实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</p></li><li><p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p></li><li><p>只能在继承层次内进行类型转换，在将超类转换成子类之前，应该使用instanceof进行检查。</p></li><li><p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。</p></li><li><p>equals和hashcode的定义必须兼容，即如果x.equals(y)为true，x.hashcode必须等于y.hashcode()。</p></li><li><p>抽象类中可以有构造方法（用于给子类对象进行初始化），而接口没有。</p></li><li><p>&amp;和&amp;&amp;区别： &amp; 无论左边结果是什么，右边都参与运算。&amp;&amp;短路与，如果左边为 false ，那么右边不参数与运算。类似|和||。</p></li><li><p>执行顺序：（优先级从高到低。）静态代码块&gt;mian方法&gt;构造代码块&gt;构造方法。其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。</p></li><li><p>this:代表对象。就是所在函数所属对象的引用。哪个对象调用了 this 所在的函数 this 就代表哪 个对象 就是哪个对象的引用。</p></li><li><p>因为staticstatic方法独立于任何实例，因此方法独立于任何实例，因此staticstatic方法必须被实现，而不能是抽象的方法必须被实现，而不能是抽象的abstractabstract。</p></li><li><p>成员变量存在于堆内存中。静态变量存在于方法区中。</p></li><li><p><img src="https://i.imgur.com/65QDJjg.jpg" alt></p></li><li><p>子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。</p></li><li><p>同步函数使用的锁是this ，静态同步函数的锁是该类的字节码文件对象 。</p></li><li><p>wait 线程会释放执行权，而且线程会释放锁。sleep线程会释放执行权，但不是不释放锁。</p></li><li><p>对于ArrayList 集合，判断元素是否存在，或者删元素底层依据都是 equals 方法。对于HashSet 集合，判断元素是否存在，或者删除元素，底层依据的是 hashCode 方法和 equals方法。</p></li><li><p>为了优化，虚拟机为包装类提供了缓冲池， <strong>Integer 池的大小 128~127 一个字节的大小。</strong></p></li><li><p>javac常量优化。给一个变量赋值，如果等于号的右边是常量的表达式并且没有一个变量，那么就会在编译阶段计算该表达式的结果，然后判断该表达式的结果是否在左边类型所表示范围内，如果在，那么就赋值成功，如果不在，那么就赋值失败。</p></li><li><p>Class类继承Object，并且实现了若干个接口，每当classloader从class文件中加载一个类时，都会加载类型信息到方法区中，同时生成一个Class对象，该类型信息的具体数据结构根据不同的虚拟机实现而不同，但是该数据结构肯定有一个引用指向该Class对象，以便诸如String.class的时候可以获取到该Class对象，而该Class对象一定有一个引用指向该类型信息结构，以便通过Class获取fields，methods以及其他数据, 因为这些数据存在方法区中。Class对象存放在堆中。</p></li><li><p>常量池的分类：<strong>class文件常量池</strong>。常量池(Constant Pool Table)【此时没有加载进内存，也就是在文件中】，用于存放编译期生成的各种字面量和符号引用。<strong>运行时常量池</strong>。我们知道类加载器会加载对应的Class文件，而上面的class文件中的常量池，会在类加载后进入方法区中的运行时常量池【此时存在在内存中】。并且需要的注意的是，运行时常量池是全局共享的，多个类共用一个运行时常量池。并且class文件中常量池多个相同的字符串在运行时常量池只会存在一份。<strong>字符串常量池。</strong>上面我们说常量池中的字面量会在类加载后进入运行时常量池，其中字面量中有包括文本字符串，显然从这段文字我们可以知道字符串常量池存在于运行时常量池中。也就存在于方法区中。到了JDK1.7时，字符串常量池就被移出了方法区，转移到了堆里了。<strong>那么我们可以推断，到了JDK1.7以及之后的版本中，运行时常量池并没有包含字符串常量池，运行时常量池存在于方法区中，而字符串常量池存在于堆中。</strong></p></li><li><p>字符串效果上相当于char字符数组，但是底层原理是byte字节数组。</p></li><li><p>接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p></li><li><p><strong>类优先。</strong>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p></li><li><p><img src="https://i.imgur.com/zkNrmdW.jpg" alt></p></li><li><p>内部类可以直接访问外部类的成员，包括私有成员。外部类要访问内部类的成员，必须要建立内部类的对象。</p></li><li><p><img src="https://i.imgur.com/2U6IRAF.jpg" alt></p></li><li></li></ul><hr><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><h4 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理 的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《 Java 虚拟机规范（第 2 版）》的规定， Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：<br><img src="https://i.imgur.com/pTCHO7U.jpg" alt="运行时数据区域"></p><h4 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2. 程序计数器"></a>2. 程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 <strong>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 **如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的Natvie方法，这个计数器值则为空（Undefined）。</strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**</p><h4 id="3-Java虚拟机栈"><a href="#3-Java虚拟机栈" class="headerlink" title="3. Java虚拟机栈"></a>3. Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）<strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong><br><br>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。<br><br>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 <br><br><strong>其中64位长度的long和double类型的数据会占用2个局部变量空间</strong>（Slot），其余的数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong> 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h4 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4. 本地方法栈"></a>4. 本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h4 id="5-Java堆"><a href="#5-Java堆" class="headerlink" title="5. Java堆"></a>5. Java堆</h4><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br><br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配和回收等细节将会是下一章的主题。<br><br>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6. 方法区"></a>6. 方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><h4 id="7-运行时常量池"><a href="#7-运行时常量池" class="headerlink" title="7. 运行时常量池"></a>7. 运行时常量池</h4><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分。</strong>Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），<strong>用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong> Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h4 id="8-对象访问"><a href="#8-对象访问" class="headerlink" title="8. 对象访问"></a>8. 对象访问</h4><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码： Object obj = new Object(); 假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。<br><br>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：<em><em>使用句柄和直接指针。 </em></em>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：</p><p><img src="https://i.imgur.com/VAbtvoY.jpg" alt></p><p><strong>如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：</strong><br><img src="https://i.imgur.com/ES794ij.jpg" alt></p><p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2019/12/08/article-title/"/>
      <url>/2019/12/08/article-title/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
