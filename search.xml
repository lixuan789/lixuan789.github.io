<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java高级知识</title>
      <link href="/2019/12/10/java-advance/"/>
      <url>/2019/12/10/java-advance/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><ul><li><code>java.util.HashSet</code> 底层的实现其实是一个<code>java.util.HashMap</code> 支持。</li><li>HashSet集合存储数据的结构（哈希表）<br>在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<br><img src="https://i.imgur.com/N5szJnF.jpg" alt="哈希表"></li><li>可变参数。同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</li><li><a href="https://www.jianshu.com/p/63e76826e852" title="集合框架" target="_blank" rel="noopener">https://www.jianshu.com/p/63e76826e852</a></li><li>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</li><li>Comparable 和 Comparator 的对比<br>Comparable 更像是自然排序<br>Comparator 更像是定制排序<br>同时存在时采用 Comparator（定制排序）的规则进行比较。对于一些普通的数据类型（比如 String, Integer, Double…），它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。<br><img src="https://i.imgur.com/khQN4IB.png" alt="对比"></li></ul><hr><h1 id="异常和线程"><a href="#异常和线程" class="headerlink" title="异常和线程"></a>异常和线程</h1><ul><li>异常的分类<br><img src="https://i.imgur.com/vQAtiaH.png" alt="异常分类"></li><li>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</li><li>Thread和Runnable的区别<br><img src="https://i.imgur.com/842axaw.png" alt="Thread和Runnable的区别"></li><li>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li><li>线程同步。<ol><li>同步代码块</li><li>同步方法：对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</li><li>锁机制</li></ol></li><li>线程状态<br><img src="https://i.imgur.com/bkpUhty.png" alt="线程状态"><br><img src="https://i.imgur.com/h30OsO3.png" alt="状态转移"></li><li>线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li><li>Lambda省略：<ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内有且仅有一个参，则小括号可以省略；</li><li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。<br><img src="https://i.imgur.com/rCZGMrn.png" alt="注意事项"></li></ol></li></ul><hr><h1 id="File类和IO流"><a href="#File类和IO流" class="headerlink" title="File类和IO流"></a>File类和IO流</h1><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。<ul><li><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code>作为参数，接口中只有一个方法。<code>boolean accept(File pathname)</code>：测试pathname是否应该包含在当前File目录中，符合则返回true。</li></ul></li><li>分类<br><img src="https://i.imgur.com/PS1aD9a.jpg" alt="分类"></li><li><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时， <code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</li><li>序列化<br><img src="https://i.imgur.com/DIvNllw.png" alt="序列化"></li></ul><hr><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><ul><li><code>java.util.function.Supplier&lt;T&gt;</code> 接口仅包含一个无参的方法： <code>T get()</code> 。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。</li><li><code>java.util.function.Consumer&lt;T&gt;</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。    1. Consumer接口中包含抽象方法<code>void accept(T t)</code> ，意为消费一个指定泛型的数据。<ol start="2"><li>如果一个方法的参数和返回值全都是Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是Consumer接口中的default方法<code>andThen</code></li></ol></li><li>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code> 接口。<ol><li>抽象方法。<code>boolean test(T t)</code> 。用于条件判断。</li><li>默认方法。and、or、negate</li></ol></li><li><code>java.util.function.Function&lt;T,R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。Function的前置条件泛型和后置条件泛型可以相同。<ol><li>Function 接口中最主要的抽象方法为： <code>R apply(T t)</code> ，根据类型T的参数获取类型R的结果。</li><li>Function 接口中有一个默认的<code>andThen</code> 方法，用来进行组合操作。</li></ol></li></ul><hr><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><ul><li>获取流<ol><li>所有的Collection 集合都可以通过stream 默认方法获取流；</li><li>Stream 接口的静态方法of 可以获取数组对应的流。</li></ol></li><li>常用方法<ol><li><code>void forEach(Consumer&lt;? super T&gt; action);</code></li><li><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code>。可以通过filter 方法将一个流转换成另一个子集流。</li><li><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code>将流中的元素映射到另一个流中，可以使用map 方法。</li><li><code>long count();</code>。正如旧集合Collection 当中的size 方法一样，流提供count 方法来数一数其中的元素个数。</li><li><code>Stream&lt;T&gt; limit(long maxSize);</code>。limit 方法可以对流进行截取，只取用前n个。</li><li><code>Stream&lt;T&gt; skip(long n);</code>。如果希望跳过前几个元素，可以使用skip 方法获取一个截取之后的新流。</li><li><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code>。合并成为一个流。</li></ol></li></ul><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li><p>获取Class对象的方式：</p><ol><li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li></ul></li><li>类名.class：通过类名的属性class获取<ul><li>多用于参数的传递</li></ul></li><li>对象.getClass()：getClass()方法在Object类中定义着。<ul><li>多用于对象的获取字节码的方式</li></ul></li></ol><ul><li>结论：<br>  同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li></ul></li><li><p>Class对象功能：</p><ul><li><p>获取功能：</p><ol><li><p>获取成员变量们</p><ul><li><p>Field[] getFields() ：获取所有public修饰的成员变量</p></li><li><p>Field getField(String name)   获取指定名称的 public修饰的成员变量</p></li><li><p>Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</p></li><li><p>Field getDeclaredField(String name)  </p></li></ul></li><li><p>获取构造方法们</p><ul><li><p>Constructor&lt;?&gt;[] getConstructors()  </p></li><li><p>Constructor<t> getConstructor(类&lt;?&gt;… parameterTypes)  </t></p></li><li><p>Constructor<t> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)  </t></p></li><li><p>Constructor&lt;?&gt;[] getDeclaredConstructors()  </p></li></ul></li><li><p>获取成员方法们：</p><ul><li><p>Method[] getMethods()  </p></li><li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)  </p></li><li><p>Method[] getDeclaredMethods()  </p></li><li><p>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)  </p></li></ul></li><li><p>获取全类名    </p><ul><li>String getName() </li></ul></li></ol></li></ul></li><li><p>Field：成员变量</p><ul><li><p>操作：</p><ol><li><p>设置值</p><ul><li>void set(Object obj, Object value)  </li></ul></li><li><p>获取值</p><ul><li>get(Object obj) </li></ul></li><li><p>忽略访问权限修饰符的安全检查</p><ul><li>setAccessible(true):暴力反射</li></ul></li></ol></li></ul></li></ul><ul><li><p>Constructor:构造方法</p><ul><li><p>创建对象：</p><ul><li><p>T newInstance(Object… initargs)  </p></li><li><p>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p></li></ul></li></ul></li></ul><ul><li><p>Method：方法对象</p><ul><li><p>执行方法：</p><ul><li>Object invoke(Object obj, Object… args)  </li></ul></li><li><p>获取方法名称：</p><ul><li>String getName:获取方法名</li></ul></li></ul></li></ul><hr><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><ul><li><p>概念：说明程序的。给计算机看的</p></li><li><p>注释：用文字描述程序的。给程序员看的</p></li><li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></li><li><p>概念描述：</p><ul><li>JDK1.5之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul></li></ul><ul><li>作用分类：<br>  ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】<br>  ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】<br>  ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li></ul><ul><li><p>JDK中预定义的一些注解</p><ul><li>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</li><li>@Deprecated：该注解标注的内容，表示已过时</li><li>@SuppressWarnings：压制警告<ul><li>一般传递参数all  @SuppressWarnings(“all”)</li></ul></li></ul></li><li><p>自定义注解</p><ul><li><p>格式：<br>  元注解<br>  public @interface 注解名称{</p><pre><code>  属性列表;</code></pre><p>  }</p></li><li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p><ul><li>public interface MyAnno extends java.lang.annotation.Annotation {}</li></ul></li><li><p>属性：接口中的抽象方法</p><ul><li><p>要求：</p><ol><li><p>属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>定义了属性，在使用时需要给属性赋值</p><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ol></li></ol></li></ul></li><li><p>元注解：用于描述注解的注解</p><ul><li>@Target：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段<ul><li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li></ul></li><li>@Documented：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul></li></ul></li></ul><ul><li><p>在程序使用(解析)注解：获取注解中定义的属性值</p><ol><li><p>获取注解定义的位置的对象  （Class，Method,Field）</p></li><li><p>获取指定的注解</p><ul><li><p>getAnnotation(Class)<br>//其实就是在内存中生成了一个该注解接口的子类实现对象</p><pre><code>  public class ProImpl implements Pro{      public String className(){          return &quot;cn.itcast.annotation.Demo1&quot;;      }      public String methodName(){          return &quot;show&quot;;      }  }</code></pre></li></ul></li><li><p>调用注解中的抽象方法获取配置的属性值</p></li></ol></li><li><p>小结：</p><ol><li>以后大多数时候，我们会使用注解，而不是自定义注解</li><li>注解给谁用？<ol><li>编译器</li><li>给解析程序用</li></ol></li><li>注解不是程序的一部分，可以理解为注解就是一个标签</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识点总结</title>
      <link href="/2019/12/09/hello-world/"/>
      <url>/2019/12/09/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a><strong>Java基础知识</strong></h3><ul><li><p>在Java中，所有的数值类型所占据的字节数量与平台无关。</p></li><li><p>Java实际上没有多维数组，只有一维数组。</p></li><li><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p></li><li><p>构造器总是伴随着new操作符的执行被调用。</p></li><li><p>可以认为静态方法是没有this参数的方法。</p></li><li><p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</strong></p></li><li><p>必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的域，将会自动初始化为默认值（0，false或null）。</p></li><li><p>在Java 中，所有的继承都是公有继承。</p></li><li><p>有些人认为super与this引用是类似的概念， 实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</p></li><li><p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p></li><li><p>只能在继承层次内进行类型转换，在将超类转换成子类之前，应该使用instanceof进行检查。</p></li><li><p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。</p></li><li><p>equals和hashcode的定义必须兼容，即如果x.equals(y)为true，x.hashcode必须等于y.hashcode()。</p></li><li><p>抽象类中可以有构造方法（用于给子类对象进行初始化），而接口没有。</p></li><li><p>&amp;和&amp;&amp;区别： &amp; 无论左边结果是什么，右边都参与运算。&amp;&amp;短路与，如果左边为 false ，那么右边不参数与运算。类似|和||。</p></li><li><p>执行顺序：（优先级从高到低。）静态代码块&gt;mian方法&gt;构造代码块&gt;构造方法。其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。</p></li><li><p>this:代表对象。就是所在函数所属对象的引用。哪个对象调用了 this 所在的函数 this 就代表哪 个对象 就是哪个对象的引用。</p></li><li><p>因为staticstatic方法独立于任何实例，因此方法独立于任何实例，因此staticstatic方法必须被实现，而不能是抽象的方法必须被实现，而不能是抽象的abstractabstract。</p></li><li><p>成员变量存在于堆内存中。静态变量存在于方法区中。</p></li><li><p><img src="https://i.imgur.com/65QDJjg.jpg" alt></p></li><li><p>子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。</p></li><li><p>同步函数使用的锁是this ，静态同步函数的锁是该类的字节码文件对象 。</p></li><li><p>wait 线程会释放执行权，而且线程会释放锁。sleep线程会释放执行权，但不是不释放锁。</p></li><li><p>对于ArrayList 集合，判断元素是否存在，或者删元素底层依据都是 equals 方法。对于HashSet 集合，判断元素是否存在，或者删除元素，底层依据的是 hashCode 方法和 equals方法。</p></li><li><p>为了优化，虚拟机为包装类提供了缓冲池， <strong>Integer 池的大小 128~127 一个字节的大小。</strong></p></li><li><p>javac常量优化。给一个变量赋值，如果等于号的右边是常量的表达式并且没有一个变量，那么就会在编译阶段计算该表达式的结果，然后判断该表达式的结果是否在左边类型所表示范围内，如果在，那么就赋值成功，如果不在，那么就赋值失败。</p></li><li><p>Class类继承Object，并且实现了若干个接口，每当classloader从class文件中加载一个类时，都会加载类型信息到方法区中，同时生成一个Class对象，该类型信息的具体数据结构根据不同的虚拟机实现而不同，但是该数据结构肯定有一个引用指向该Class对象，以便诸如String.class的时候可以获取到该Class对象，而该Class对象一定有一个引用指向该类型信息结构，以便通过Class获取fields，methods以及其他数据, 因为这些数据存在方法区中。Class对象存放在堆中。</p></li><li><p>常量池的分类：<strong>class文件常量池</strong>。常量池(Constant Pool Table)【此时没有加载进内存，也就是在文件中】，用于存放编译期生成的各种字面量和符号引用。<strong>运行时常量池</strong>。我们知道类加载器会加载对应的Class文件，而上面的class文件中的常量池，会在类加载后进入方法区中的运行时常量池【此时存在在内存中】。并且需要的注意的是，运行时常量池是全局共享的，多个类共用一个运行时常量池。并且class文件中常量池多个相同的字符串在运行时常量池只会存在一份。<strong>字符串常量池。</strong>上面我们说常量池中的字面量会在类加载后进入运行时常量池，其中字面量中有包括文本字符串，显然从这段文字我们可以知道字符串常量池存在于运行时常量池中。也就存在于方法区中。到了JDK1.7时，字符串常量池就被移出了方法区，转移到了堆里了。<strong>那么我们可以推断，到了JDK1.7以及之后的版本中，运行时常量池并没有包含字符串常量池，运行时常量池存在于方法区中，而字符串常量池存在于堆中。</strong></p></li><li><p>字符串效果上相当于char字符数组，但是底层原理是byte字节数组。</p></li><li><p>接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p></li><li><p><strong>类优先。</strong>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p></li><li><p><img src="https://i.imgur.com/zkNrmdW.jpg" alt></p></li><li><p>内部类可以直接访问外部类的成员，包括私有成员。外部类要访问内部类的成员，必须要建立内部类的对象。</p></li><li><p><img src="https://i.imgur.com/2U6IRAF.jpg" alt></p></li><li></li></ul><hr><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><h4 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理 的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《 Java 虚拟机规范（第 2 版）》的规定， Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：<br><img src="https://i.imgur.com/pTCHO7U.jpg" alt="运行时数据区域"></p><h4 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2. 程序计数器"></a>2. 程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 <strong>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 **如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的Natvie方法，这个计数器值则为空（Undefined）。</strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**</p><h4 id="3-Java虚拟机栈"><a href="#3-Java虚拟机栈" class="headerlink" title="3. Java虚拟机栈"></a>3. Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）<strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong><br><br>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。<br><br>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 <br><br><strong>其中64位长度的long和double类型的数据会占用2个局部变量空间</strong>（Slot），其余的数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong> 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h4 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4. 本地方法栈"></a>4. 本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h4 id="5-Java堆"><a href="#5-Java堆" class="headerlink" title="5. Java堆"></a>5. Java堆</h4><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br><br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配和回收等细节将会是下一章的主题。<br><br>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6. 方法区"></a>6. 方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><h4 id="7-运行时常量池"><a href="#7-运行时常量池" class="headerlink" title="7. 运行时常量池"></a>7. 运行时常量池</h4><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分。</strong>Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），<strong>用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong> Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h4 id="8-对象访问"><a href="#8-对象访问" class="headerlink" title="8. 对象访问"></a>8. 对象访问</h4><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码： Object obj = new Object(); 假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。<br><br>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：<em><em>使用句柄和直接指针。 </em></em>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：</p><p><img src="https://i.imgur.com/VAbtvoY.jpg" alt></p><p><strong>如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：</strong><br><img src="https://i.imgur.com/ES794ij.jpg" alt></p><p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
